---
const { slides = [] } = Astro.props;
const serialized = JSON.stringify(slides);
---
<div
  class="projects-carousel"
  data-carousel
  data-slide-count={slides.length}
  data-slides={serialized}
  tabindex="0"
  aria-roledescription="carousel"
  aria-label="Highlighted projects"
>
  <button
    class="carousel-control carousel-control--prev"
    type="button"
    data-carousel-prev
    aria-label="View previous project"
  >
    <span aria-hidden="true">&lt;</span>
  </button>
  <div class="projects-carousel-track" data-carousel-track>
    {slides.map((project, index) => {
      const gradientFrom = project.gradientFrom ?? "#1f2937";
      const gradientTo = project.gradientTo ?? "#0f172a";
      const mediaValue = project.image ? `url("${project.image}")` : "none";
      const initialOffset = index;
      return (
        <article
          class={`carousel-slide${index === 0 ? " is-active" : ""}`}
          data-carousel-slide
          data-index={index}
          style={`--card-gradient-from: ${gradientFrom}; --card-gradient-to: ${gradientTo}; --card-media: ${mediaValue}; --offset: ${initialOffset}; --abs-offset: ${Math.abs(initialOffset)}; --direction: ${initialOffset === 0 ? 0 : 1};`}
          aria-hidden={index === 0 ? "false" : "true"}
        >
          <div class="carousel-card">
            <div class="carousel-card-body">
              <h3>{project.title}</h3>
              <p>{project.description}</p>
              {project.link && project.cta ? (
                project.link === '#' ? (
                  <button class="carousel-link" data-popup-trigger={project.title}>
                    {project.cta}
                  </button>
                ) : (
                  <a class="carousel-link" href={project.link}>
                    {project.cta}
                  </a>
                )
              ) : null}
            </div>
          </div>
        </article>
      );
    })}
  </div>
  <button
    class="carousel-control carousel-control--next"
    type="button"
    data-carousel-next
    aria-label="View next project"
  >
    <span aria-hidden="true">&gt;</span>
  </button>
  <div class="carousel-dots" role="tablist">
    {slides.map((project, index) => (
      <button
        type="button"
        class={`carousel-dot${index === 0 ? " is-active" : ""}`}
        data-carousel-dot
        data-index={index}
        role="tab"
        aria-label={`Go to slide ${index + 1}`}
        aria-pressed={index === 0 ? "true" : "false"}
      />
    ))}
  </div>
</div>

<div id="popup" class="popup">
  <p>This section is under construction</p>
</div>

<style>
  .popup {
    display: none;
    position: fixed;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    background-color: #EEE2DC;
    color: #123C69;
    padding: 30px;
    border-radius: 15px;
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
    z-index: 1000;
    font-family: 'Inter', 'Segoe UI', Arial, sans-serif;
    max-width: 320px;
    text-align: center;
  }

  .popup p {
    margin: 0;
    font-size: 1.1rem;
  }
</style>

<script>
  const popup = document.getElementById('popup');
  const popupTriggers = document.querySelectorAll('[data-popup-trigger]');

  popupTriggers.forEach(trigger => {
    trigger.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      popup.style.display = 'block';
    });
  });

  // Close popup when clicking anywhere in the window except inside the popup
  window.addEventListener('click', function(event) {
    if (popup.style.display === 'block' && !popup.contains(event.target)) {
      popup.style.display = 'none';
    }
  });
  
  // Close popup when scrolling
  window.addEventListener('scroll', function() {
    popup.style.display = 'none';
  });
  
  // Prevent closing when clicking inside the popup content
  popup.addEventListener('click', function(event) {
    event.stopPropagation();
  });
</script>

{slides.length > 1 ? (
  <script type="module">
    const initProjectsCarousels = () => {
      const carousels = document.querySelectorAll('[data-carousel]');
      carousels.forEach((carousel) => {
        const slides = Array.from(
          carousel.querySelectorAll('[data-carousel-slide]')
        );
        if (slides.length === 0) {
          return;
        }

        const dots = Array.from(
          carousel.querySelectorAll('[data-carousel-dot]')
        );
        const prevBtn = carousel.querySelector('[data-carousel-prev]');
        const nextBtn = carousel.querySelector('[data-carousel-next]');
        const track = carousel.querySelector('[data-carousel-track]');
        let currentIndex = 0;
        let timerId = null;
        let autoPlay = slides.length > 1;
        let pointerActive = false;
        let pointerId = null;
        let dragStartX = 0;
        const dragThreshold = 45;
        const transitionDuration = 620;
        let isAnimating = false;
        let animationTimeoutId = null;
        let pendingTarget = null;

        carousel.dataset.carouselDirection = carousel.dataset.carouselDirection || 'forward';

        const getLogicalOffset = (slideIndex) => {
          let offset = slideIndex - currentIndex;
          const half = Math.floor(slides.length / 2);
          if (offset > half) {
            offset -= slides.length;
          } else if (offset < -half) {
            offset += slides.length;
          }
          return offset;
        };

        const updateSlides = () => {
          slides.forEach((slide, index) => {
            const offset = getLogicalOffset(index);
            const absOffset = Math.abs(offset);
            slide.style.setProperty('--offset', offset.toString());
            slide.style.setProperty('--abs-offset', absOffset.toString());
            slide.style.setProperty('--direction', Math.sign(offset).toString());
            slide.classList.toggle('is-active', index === currentIndex);
            slide.setAttribute('aria-hidden', index === currentIndex ? 'false' : 'true');
          });

          dots.forEach((dot, index) => {
            const isActive = index === currentIndex;
            dot.classList.toggle('is-active', isActive);
            dot.setAttribute('aria-pressed', isActive ? 'true' : 'false');
          });
        };

        const resolveDirection = (fromIndex, toIndex) => {
          const total = slides.length;
          const forwardDistance = (toIndex - fromIndex + total) % total;
          const backwardDistance = (fromIndex - toIndex + total) % total;
          if (forwardDistance === backwardDistance) {
            return carousel.dataset.carouselDirection || 'forward';
          }
          return forwardDistance <= backwardDistance ? 'forward' : 'backward';
        };

        const beginTransition = (targetIndex, triggeredByUser) => {
          isAnimating = true;
          const previousIndex = currentIndex;
          const direction = resolveDirection(previousIndex, targetIndex);
          carousel.dataset.carouselDirection = direction;
          currentIndex = targetIndex;
          updateSlides();
          if (triggeredByUser) {
            stopAutoPlay();
          }
          window.clearTimeout(animationTimeoutId);
          animationTimeoutId = window.setTimeout(() => {
            isAnimating = false;
            if (pendingTarget) {
              const { index: nextIndex, userInitiated } = pendingTarget;
              pendingTarget = null;
              beginTransition(nextIndex, userInitiated);
            }
          }, transitionDuration);
        };

        const goTo = (nextIndex, triggeredByUser = false) => {
          if (slides.length === 0) {
            return;
          }
          const total = slides.length;
          const normalized = ((nextIndex % total) + total) % total;
          if (normalized === currentIndex) {
            if (triggeredByUser) {
              stopAutoPlay();
            }
            return;
          }

          if (isAnimating) {
            pendingTarget = { index: normalized, userInitiated: triggeredByUser };
            if (triggeredByUser) {
              stopAutoPlay();
            }
            return;
          }

          beginTransition(normalized, triggeredByUser);
        };

        const goNext = (user = false) => goTo(currentIndex + 1, user);
        const goPrev = (user = false) => goTo(currentIndex - 1, user);

        const stopAutoPlay = () => {
          if (timerId !== null) {
            window.clearInterval(timerId);
            timerId = null;
          }
          autoPlay = false;
        };

        const startAutoPlay = () => {
          if (!autoPlay || slides.length < 2) {
            return;
          }
          if (timerId) {
            window.clearInterval(timerId);
          }
          timerId = window.setInterval(() => {
            goNext();
          }, 5000);
        };

        if (nextBtn) {
          nextBtn.addEventListener('click', () => goNext(true));
        }
        if (prevBtn) {
          prevBtn.addEventListener('click', () => goPrev(true));
        }

        if (track) {
          const resetPointer = () => {
            pointerActive = false;
            pointerId = null;
          };

          track.addEventListener('pointerdown', (event) => {
            if (event.pointerType !== 'touch' && event.pointerType !== 'pen') {
              return;
            }
            pointerActive = true;
            pointerId = event.pointerId;
            dragStartX = event.clientX;
            track.setPointerCapture(pointerId);
          });

          track.addEventListener('pointermove', (event) => {
            if (!pointerActive || event.pointerId !== pointerId) {
              return;
            }
            const deltaX = event.clientX - dragStartX;
            if (Math.abs(deltaX) < dragThreshold) {
              return;
            }
            if (deltaX > 0) {
              goPrev(true);
            } else {
              goNext(true);
            }
            track.releasePointerCapture(pointerId);
            resetPointer();
          });

          track.addEventListener('pointerup', (event) => {
            if (event.pointerId === pointerId) {
              track.releasePointerCapture(pointerId);
              resetPointer();
            }
          });

          track.addEventListener('pointercancel', () => {
            if (pointerId !== null) {
              track.releasePointerCapture(pointerId);
            }
            resetPointer();
          });
        }

        dots.forEach((dot) => {
          dot.addEventListener('click', () => {
            const target = Number.parseInt(dot.dataset.index || '0', 10);
            goTo(target, true);
          });
        });

        const cancelAuto = () => {
          if (!autoPlay) {
            return;
          }
          stopAutoPlay();
        };

        ['pointerdown', 'keydown', 'touchstart', 'focusin'].forEach((evt) => {
          carousel.addEventListener(evt, cancelAuto, { once: true });
        });

        carousel.addEventListener('keydown', (event) => {
          if (event.key === 'ArrowRight') {
            goNext(true);
            event.preventDefault();
          } else if (event.key === 'ArrowLeft') {
            goPrev(true);
            event.preventDefault();
          }
        });

        updateSlides();
        startAutoPlay();
      });
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initProjectsCarousels);
    } else {
      initProjectsCarousels();
    }
  </script>
) : null}

